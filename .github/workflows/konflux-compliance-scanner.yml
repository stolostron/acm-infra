name: Konflux Compliance Scanner

on:
  # schedule:
  #   # Run at 8:00 AM EST (13:00 UTC) and 1:00 PM EST (18:00 UTC), every day including weekends
  #   - cron: '0 13,18 * * *'

  workflow_dispatch:
    inputs:
      application:
        description: 'Application name (e.g., acm-215, mce-29, or "all")'
        required: false
        default: 'all'
      retrigger_failed:
        description: 'Retrigger failed builds'
        type: boolean
        default: false
      create_jira_issues:
        description: 'Create JIRA issues for compliance failures'
        type: boolean
        default: true
      squad_filter:
        description: 'Filter by squad (optional)'
        required: false

env:
  JIRA_SERVER: "https://issues.redhat.com"
  JIRA_PROJECT: "ACM"
  JIRA_AUTH_TYPE: "bearer"
  JIRA_INSTALLATION: "Local"
  JIRA_BOARD: "None"
  JIRA_PRIORITY: "Critical"
  JIRA_LABELS: "konflux,compliance,auto-created"
  SKIP_DUPLICATES: "true"
  AUTO_CLOSE: "true"

jobs:
  compliance-scan:
    name: Scan ${{ matrix.application }}
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      max-parallel: 1
      matrix:
        application:
          - acm-211
          - acm-212
          - acm-213
          - acm-214
          - acm-215
          - acm-216
          - mce-26
          - mce-27
          - mce-28
          - mce-29
          - mce-210
          - mce-211

    steps:
      - name: Check if should run
        id: should_run
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            APP_INPUT="${{ github.event.inputs.application }}"
            if [[ "$APP_INPUT" != "all" && "$APP_INPUT" != "${{ matrix.application }}" ]]; then
              echo "skip=true" >> $GITHUB_OUTPUT
              echo "Skipping ${{ matrix.application }} (only running $APP_INPUT)"
            else
              echo "skip=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Install required tools
        if: steps.should_run.outputs.skip != 'true'
        run: |
          # Install kubectl only if not available (for local act testing)
          if ! command -v kubectl &> /dev/null; then
            echo "Installing kubectl..."
            KUBECTL_VERSION=$(curl -L -s https://dl.k8s.io/release/stable.txt)
            # Use wget with better retry logic, fallback to curl if wget unavailable
            if command -v wget &> /dev/null; then
              wget --retry-connrefused --waitretry=1 --read-timeout=20 --timeout=15 --tries=3 \
                -O kubectl "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
            else
              curl -L --retry 5 --retry-delay 3 --retry-max-time 120 --connect-timeout 30 --max-time 300 \
                -C - -o kubectl "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
            fi
            sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
            rm -f kubectl
          else
            echo "kubectl already installed"
          fi

          # Install OpenShift CLI (oc)
          if ! command -v oc &> /dev/null; then
            echo "Installing OpenShift CLI (oc)..."
            OC_VERSION="4.17.8"
            # Use wget with better retry logic, fallback to curl if wget unavailable
            if command -v wget &> /dev/null; then
              wget --retry-connrefused --waitretry=1 --read-timeout=20 --timeout=15 --tries=3 \
                -O openshift-client-linux.tar.gz \
                "https://mirror.openshift.com/pub/openshift-v4/clients/ocp/${OC_VERSION}/openshift-client-linux.tar.gz"
            else
              curl -L --retry 5 --retry-delay 3 --retry-max-time 120 --connect-timeout 30 --max-time 300 \
                -C - -o openshift-client-linux.tar.gz \
                "https://mirror.openshift.com/pub/openshift-v4/clients/ocp/${OC_VERSION}/openshift-client-linux.tar.gz"
            fi
            tar -xzf openshift-client-linux.tar.gz oc
            sudo install -o root -g root -m 0755 oc /usr/local/bin/oc
            rm -f openshift-client-linux.tar.gz oc kubectl
          else
            echo "oc already installed"
          fi

          echo "Installing yq..."
          sudo curl -L --retry 3 --retry-delay 2 --fail https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64 -o /usr/local/bin/yq
          sudo chmod +x /usr/local/bin/yq

          echo "Installing jira-cli..."
          JIRA_CLI_VERSION=$(curl -s --retry 3 --retry-delay 2 https://api.github.com/repos/ankitpokhrel/jira-cli/releases/latest | jq -r '.tag_name' | sed 's/^v//')
          curl -L --retry 3 --retry-delay 2 --fail -o "jira_${JIRA_CLI_VERSION}_linux_x86_64.tar.gz" "https://github.com/ankitpokhrel/jira-cli/releases/download/v${JIRA_CLI_VERSION}/jira_${JIRA_CLI_VERSION}_linux_x86_64.tar.gz"
          tar -xzf "jira_${JIRA_CLI_VERSION}_linux_x86_64.tar.gz"
          # Find the jira binary and move it to /usr/local/bin
          find . -name "jira" -type f -executable -exec sudo mv {} /usr/local/bin/jira \;
          sudo chmod +x /usr/local/bin/jira
          rm -rf "jira_${JIRA_CLI_VERSION}_linux_x86_64.tar.gz" bin completions man

          echo "Installing skopeo..."
          sudo apt-get update
          sudo apt-get install -y skopeo

          echo "Verifying installations..."
          kubectl version --client
          oc version --client
          yq --version
          jira version
          skopeo --version

      - name: Checkout repository
        if: steps.should_run.outputs.skip != 'true'
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          submodules: 'recursive'

      - name: Setup scripts
        if: steps.should_run.outputs.skip != 'true'
        run: |
          echo "Using local scripts from konflux/konflux-jira-integration/scripts/"
          echo ""

          # Verify scripts exist
          if [[ ! -f "${{ github.workspace }}/konflux/konflux-jira-integration/scripts/compliance.sh" ]]; then
            echo "❌ ERROR: compliance.sh not found"
            exit 1
          fi

          if [[ ! -f "${{ github.workspace }}/konflux/konflux-jira-integration/scripts/create-compliance-jira-issues.sh" ]]; then
            echo "❌ ERROR: create-compliance-jira-issues.sh not found"
            exit 1
          fi

          echo "✓ Required scripts found"
          echo ""

          # Verify component registry configuration
          # Primary: new centralized registry from acm-config submodule
          # Fallback: old component-squad.yaml
          NEW_REGISTRY="${{ github.workspace }}/acm-config/product/component-registry.yaml"
          OLD_REGISTRY="${{ github.workspace }}/konflux/konflux-jira-integration/scripts/component-squad.yaml"

          if [[ -f "$NEW_REGISTRY" ]]; then
            echo "✓ Using new component registry: acm-config/product/component-registry.yaml"
            COMPONENT_COUNT=$(yq '.components | length' "$NEW_REGISTRY")
            echo "  Components registered: $COMPONENT_COUNT"
          elif [[ -f "$OLD_REGISTRY" ]]; then
            echo "⚠ Using legacy component-squad.yaml (new registry not found)"
            echo "  Note: Please ensure acm-config submodule is initialized"
          else
            echo "❌ ERROR: No component registry found"
            echo "  Checked: $NEW_REGISTRY"
            echo "  Checked: $OLD_REGISTRY"
            exit 1
          fi

          echo ""
          echo "✓ Configuration validated"
          echo ""
          echo "=== Scripts directory ==="
          ls -la ${{ github.workspace }}/konflux/konflux-jira-integration/scripts/
          echo ""
          echo "=== acm-config submodule status ==="
          if [[ -d "${{ github.workspace }}/acm-config" ]]; then
            ls -la ${{ github.workspace }}/acm-config/product/ || echo "  product/ directory not found"
          else
            echo "  acm-config submodule not initialized"
          fi

      - name: Setup Konflux cluster authentication
        if: steps.should_run.outputs.skip != 'true'
        env:
          KONFLUX_API_ENDPOINT: ${{ secrets.KONFLUX_API_ENDPOINT }}
          KONFLUX_API_TOKEN: ${{ secrets.KONFLUX_API_TOKEN }}
        run: |
          echo "Setting up Konflux cluster authentication..."
          echo "API Endpoint: $KONFLUX_API_ENDPOINT"

          # Test connectivity
          echo "Testing connection to Konflux cluster..."
          if ! kubectl --server="$KONFLUX_API_ENDPOINT" \
                  --token="$KONFLUX_API_TOKEN" \
                  --insecure-skip-tls-verify \
                  get namespaces 2>&1 | head -5; then
            echo ""
            echo "❌ Failed to connect to Konflux cluster"
            echo "Please check KONFLUX_API_ENDPOINT and KONFLUX_API_TOKEN secrets"
            exit 1
          fi

          echo "✓ Konflux cluster connection successful"

          # Configure kubectl
          kubectl config set-cluster konflux \
            --server="$KONFLUX_API_ENDPOINT" \
            --insecure-skip-tls-verify=true

          kubectl config set-credentials scanner \
            --token="$KONFLUX_API_TOKEN"

          kubectl config set-context konflux \
            --cluster=konflux \
            --user=scanner \
            --namespace=crt-redhat-acm-tenant

          kubectl config use-context konflux

          echo "✓ kubectl configured for Konflux cluster"

          # Configure oc (OpenShift CLI) to use the same context
          # oc shares the same kubeconfig with kubectl
          oc config set-cluster konflux \
            --server="$KONFLUX_API_ENDPOINT" \
            --insecure-skip-tls-verify=true

          oc config set-credentials scanner \
            --token="$KONFLUX_API_TOKEN"

          oc config set-context konflux \
            --cluster=konflux \
            --user=scanner \
            --namespace=crt-redhat-acm-tenant

          oc config use-context konflux

          echo "✓ oc configured for Konflux cluster"

          # Verify access to tenant namespace
          echo "Verifying access to crt-redhat-acm-tenant namespace..."
          if oc get namespace crt-redhat-acm-tenant > /dev/null 2>&1; then
            echo "✓ Access to crt-redhat-acm-tenant verified"
          else
            echo "WARNING: Cannot access crt-redhat-acm-tenant namespace"
          fi

          # Set current project/namespace for oc
          echo "Setting current OpenShift project..."
          if oc project crt-redhat-acm-tenant > /dev/null 2>&1; then
            echo "✓ Switched to project crt-redhat-acm-tenant"
          else
            echo "WARNING: Could not switch to project crt-redhat-acm-tenant"
          fi

      - name: Setup GitHub token
        if: steps.should_run.outputs.skip != 'true'
        run: |
          echo "Setting up GitHub authentication..."
          mkdir -p ${{ github.workspace }}/data
          echo "${{ secrets.GH_PAT }}" > ${{ github.workspace }}/data/authorization.txt
          chmod 600 ${{ github.workspace }}/data/authorization.txt
          echo "✓ GitHub token configured"

      - name: Setup JIRA configuration
        if: steps.should_run.outputs.skip != 'true'
        env:
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_USER: ${{ secrets.JIRA_USER }}
        run: |
          echo "Setting up JIRA CLI configuration..."

          # Create .env file for create-compliance-jira-issues.sh
          cat > ${{ github.workspace }}/.env <<EOF
          JIRA_USER=$JIRA_USER
          JIRA_API_TOKEN=$JIRA_API_TOKEN
          JIRA_AUTH_TYPE=${{ env.JIRA_AUTH_TYPE }}
          JIRA_SERVER=${{ env.JIRA_SERVER }}
          JIRA_INSTALLATION=${{ env.JIRA_INSTALLATION }}
          JIRA_PROJECT=${{ env.JIRA_PROJECT }}
          JIRA_BOARD=${{ env.JIRA_BOARD }}
          EOF

          chmod 600 ${{ github.workspace }}/.env
          echo "✓ JIRA configuration prepared"

      - name: Run compliance scan
        if: steps.should_run.outputs.skip != 'true'
        working-directory: ${{ github.workspace }}/konflux/konflux-jira-integration/scripts
        env:
          SQUAD_FILTER: ${{ github.event.inputs.squad_filter }}
        run: |
          echo "=================================================="
          echo "Running Compliance Scan for ${{ matrix.application }}"
          echo "=================================================="
          echo "Timestamp: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          echo ""

          # Build compliance command
          COMPLIANCE_CMD="./compliance.sh"

          if [[ "${{ github.event.inputs.retrigger_failed }}" == "true" ]]; then
            COMPLIANCE_CMD="$COMPLIANCE_CMD --retrigger"
            echo "Retrigger failed components: yes"
          fi

          if [[ -n "$SQUAD_FILTER" ]]; then
            COMPLIANCE_CMD="$COMPLIANCE_CMD --squad=$SQUAD_FILTER"
            echo "Squad filter: $SQUAD_FILTER"
          fi

          COMPLIANCE_CMD="$COMPLIANCE_CMD ${{ matrix.application }}"

          # Create output directories
          mkdir -p ${{ github.workspace }}/data
          mkdir -p ${{ github.workspace }}/logs

          # Enable debug output for better error tracking
          echo "=== Debug Information ==="
          echo "Current directory: $(pwd)"
          echo "Script location: $(ls -la compliance.sh)"
          echo "Environment variables:"
          echo "  GITHUB_WORKSPACE: ${{ github.workspace }}"
          echo ""

          # Export GITHUB_TOKEN for compliance.sh script
          export GITHUB_TOKEN="${{ secrets.GH_PAT }}"

          echo "Running: $COMPLIANCE_CMD"
          echo ""

          # Run with more verbose output and capture exit code
          # Use pipefail to ensure we catch failures in the pipeline
          set -o pipefail
          eval "$COMPLIANCE_CMD" 2>&1 | tee "${{ github.workspace }}/logs/${{ matrix.application }}-compliance-scan.log"
          COMPLIANCE_EXIT_CODE=$?
          set +o pipefail

          echo ""
          echo "=== Compliance Script Exit Code: $COMPLIANCE_EXIT_CODE ==="

          # The compliance.sh script creates CSV in ./data/ relative to its working directory
          # Since we're running in scripts/, the CSV is at scripts/data/
          # Move the generated CSV to the workspace data directory
          SCRIPT_CSV_FILE="./data/${{ matrix.application }}-compliance.csv"
          WORKSPACE_CSV_FILE="${{ github.workspace }}/data/${{ matrix.application }}-compliance.csv"

          echo ""
          echo "=== Files in script data directory after scan ==="
          ls -lah ./data/ || echo "Script data directory is empty or does not exist"
          echo ""

          # Move CSV file to workspace data directory if it exists
          if [[ -f "$SCRIPT_CSV_FILE" ]]; then
            echo "Moving CSV from $SCRIPT_CSV_FILE to $WORKSPACE_CSV_FILE"
            mv "$SCRIPT_CSV_FILE" "$WORKSPACE_CSV_FILE"
            echo "✓ CSV file moved successfully"
          else
            echo "❌ ERROR: Compliance CSV file not generated at: $SCRIPT_CSV_FILE"
            echo ""
            echo "=== Last 50 lines of scan log ==="
            tail -n 50 "${{ github.workspace }}/logs/${{ matrix.application }}-compliance-scan.log"
            echo ""
            echo "=== Full script data directory listing ==="
            find ./data/ -type f -ls 2>/dev/null || echo "No files found in script data directory"
            exit 1
          fi

          # Verify CSV was moved successfully
          if [[ ! -f "$WORKSPACE_CSV_FILE" ]]; then
            echo "❌ ERROR: Failed to move CSV file to workspace data directory"
            exit 1
          fi

          echo ""
          echo "✓ Compliance scan completed"
          echo "CSV file: $WORKSPACE_CSV_FILE"

          # Show summary
          TOTAL_COMPONENTS=$(tail -n +2 "$WORKSPACE_CSV_FILE" | wc -l | tr -d ' ')
          echo "Total components scanned: $TOTAL_COMPONENTS"

      - name: Create/Update JIRA issues
        if: steps.should_run.outputs.skip != 'true' && (github.event_name == 'schedule' || github.event.inputs.create_jira_issues == 'true')
        continue-on-error: true
        working-directory: ${{ github.workspace }}/konflux/konflux-jira-integration/scripts
        env:
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_USER: ${{ secrets.JIRA_USER }}
          JIRA_AUTH_TYPE: ${{ env.JIRA_AUTH_TYPE }}
          JIRA_SERVER: ${{ env.JIRA_SERVER }}
          JIRA_INSTALLATION: ${{ env.JIRA_INSTALLATION }}
          JIRA_PROJECT: ${{ env.JIRA_PROJECT }}
          JIRA_BOARD: ${{ env.JIRA_BOARD }}
        run: |
          echo "=================================================="
          echo "Creating/Updating JIRA Issues for ${{ matrix.application }}"
          echo "=================================================="
          echo ""

          CSV_FILE="${{ github.workspace }}/data/${{ matrix.application }}-compliance.csv"
          JSON_OUTPUT="${{ github.workspace }}/logs/${{ matrix.application }}-jira-issues.json"

          # Build JIRA command
          JIRA_CMD="./create-compliance-jira-issues.sh"

          if [[ "${{ env.SKIP_DUPLICATES }}" == "true" ]]; then
            JIRA_CMD="$JIRA_CMD --skip-duplicates"
          fi

          if [[ "${{ env.AUTO_CLOSE }}" == "true" ]]; then
            JIRA_CMD="$JIRA_CMD --auto-close"
          fi

          if [[ -n "${{ env.JIRA_PRIORITY }}" ]]; then
            JIRA_CMD="$JIRA_CMD --priority ${{ env.JIRA_PRIORITY }}"
          fi

          if [[ -n "${{ env.JIRA_LABELS }}" ]]; then
            JIRA_CMD="$JIRA_CMD --labels ${{ env.JIRA_LABELS }}"
          fi

          JIRA_CMD="$JIRA_CMD --output-json $JSON_OUTPUT"
          JIRA_CMD="$JIRA_CMD --continue-on-error"
          JIRA_CMD="$JIRA_CMD $CSV_FILE"

          echo "Running: $JIRA_CMD"

          # Use pipefail to ensure we catch failures in the pipeline
          set -o pipefail
          eval "$JIRA_CMD" 2>&1 | tee "${{ github.workspace }}/logs/${{ matrix.application }}-jira-creation.log"
          JIRA_EXIT_CODE=$?
          set +o pipefail

          echo ""

          if [[ $JIRA_EXIT_CODE -eq 0 ]]; then
            echo "✓ JIRA issue creation/update completed successfully"

            if [[ -f "$JSON_OUTPUT" ]]; then
              echo "JSON output: $JSON_OUTPUT"
            fi
          else
            echo "⚠ JIRA issue creation/update completed with some errors (exit code: $JIRA_EXIT_CODE)"
            echo "Please check the log file for details: logs/${{ matrix.application }}-jira-creation.log"
            echo "Note: Workflow will continue despite errors"
          fi

      - name: Upload scan results
        if: always() && steps.should_run.outputs.skip != 'true' && env.ACT != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: compliance-results-${{ matrix.application }}
          path: |
            ${{ github.workspace }}/data/${{ matrix.application }}-compliance.csv
            ${{ github.workspace }}/logs/${{ matrix.application }}-*.log
            ${{ github.workspace }}/logs/${{ matrix.application }}-*.json
          retention-days: 30

      - name: Summary
        if: steps.should_run.outputs.skip != 'true'
        run: |
          echo "=================================================="
          echo "Compliance Scan Completed Successfully"
          echo "=================================================="
          echo "Application: ${{ matrix.application }}"
          echo "Timestamp: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          echo ""
          echo "Output files:"
          echo "  - CSV: data/${{ matrix.application }}-compliance.csv"
          echo "  - Scan Log: logs/${{ matrix.application }}-compliance-scan.log"
          echo "  - JIRA Log: logs/${{ matrix.application }}-jira-creation.log"
          echo "  - JSON: logs/${{ matrix.application }}-jira-issues.json"
          echo ""
