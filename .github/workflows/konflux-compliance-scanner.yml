name: Konflux Compliance Scanner

on:
  schedule:
    # Run at 8:00 AM EST (13:00 UTC), every Sunday
    - cron: '0 13 * * 0'

  pull_request:
    branches:
      - main
    paths:
      - '.github/workflows/konflux-compliance-scanner.yml'
      - 'konflux/konflux-jira-integration/**'
      - 'acm-config/**'

  workflow_dispatch:
    inputs:
      application:
        description: 'Application name(s) - single (e.g., acm-215), multiple comma-separated (e.g., acm-214,acm-215,mce-29), or "all"'
        required: false
        default: 'all'
      retrigger_failed:
        description: 'Retrigger failed builds'
        type: boolean
        default: false
      create_jira_issues:
        description: 'Create JIRA issues for compliance failures'
        type: boolean
        default: true
      squad_filter:
        description: 'Filter by squad (optional)'
        required: false

env:
  JIRA_SERVER: "https://issues.redhat.com"
  JIRA_PROJECT: "ACM"
  JIRA_AUTH_TYPE: "bearer"
  JIRA_INSTALLATION: "Local"
  JIRA_BOARD: "None"
  JIRA_PRIORITY: "Critical"
  JIRA_LABELS: "konflux,compliance,auto-created"
  SKIP_DUPLICATES: "true"
  AUTO_CLOSE: "true"
  KUBECTL_VERSION: "1.31.0"
  OC_VERSION: "4.17.8"
  YQ_VERSION: "4.44.3"
  JIRA_CLI_VERSION: "1.5.2"
  CACHE_VERSION: "v1"

jobs:
  compliance-scan:
    name: Scan ${{ matrix.application }}
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      max-parallel: 1
      matrix:
        application:
          - acm-211
          - acm-212
          - acm-213
          - acm-214
          - acm-215
          - acm-216
          - mce-26
          - mce-27
          - mce-28
          - mce-29
          - mce-210
          - mce-211

    steps:
      - name: Check if should run
        id: should_run
        run: |
          MATRIX_APP="${{ matrix.application }}"

          # For pull_request events, only run latest versions for validation
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # Only test latest ACM and MCE versions in PRs
            if [[ "$MATRIX_APP" == "acm-216" || "$MATRIX_APP" == "mce-211" ]]; then
              echo "skip=false" >> $GITHUB_OUTPUT
              echo "Running $MATRIX_APP (PR validation mode - latest versions only)"
            else
              echo "skip=true" >> $GITHUB_OUTPUT
              echo "Skipping $MATRIX_APP (PR validation mode - only testing latest versions)"
            fi
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            APP_INPUT="${{ github.event.inputs.application }}"

            # If "all", run everything
            if [[ "$APP_INPUT" == "all" ]]; then
              echo "skip=false" >> $GITHUB_OUTPUT
              echo "Running $MATRIX_APP (all applications selected)"
            # If input contains comma, treat as list
            elif [[ "$APP_INPUT" == *","* ]]; then
              # Convert comma-separated list to array and check if current matrix app is in the list
              IFS=',' read -ra APP_LIST <<< "$APP_INPUT"
              FOUND=false
              for app in "${APP_LIST[@]}"; do
                # Trim whitespace
                app=$(echo "$app" | xargs)
                if [[ "$app" == "$MATRIX_APP" ]]; then
                  FOUND=true
                  break
                fi
              done

              if [[ "$FOUND" == "true" ]]; then
                echo "skip=false" >> $GITHUB_OUTPUT
                echo "Running $MATRIX_APP (found in list: $APP_INPUT)"
              else
                echo "skip=true" >> $GITHUB_OUTPUT
                echo "Skipping $MATRIX_APP (not in list: $APP_INPUT)"
              fi
            # Single application name
            elif [[ "$APP_INPUT" == "$MATRIX_APP" ]]; then
              echo "skip=false" >> $GITHUB_OUTPUT
              echo "Running $MATRIX_APP (exact match)"
            else
              echo "skip=true" >> $GITHUB_OUTPUT
              echo "Skipping $MATRIX_APP (only running $APP_INPUT)"
            fi
          else
            # For scheduled runs, run all applications
            echo "skip=false" >> $GITHUB_OUTPUT
            echo "Running $MATRIX_APP (scheduled run)"
          fi

      - name: Cache CLI tools
        uses: actions/cache@v4
        id: cache-tools
        if: steps.should_run.outputs.skip != 'true'
        with:
          path: /tmp/acm-tools
          key: cli-tools-${{ runner.os }}-kubectl-${{ env.KUBECTL_VERSION }}-oc-${{ env.OC_VERSION }}-yq-${{ env.YQ_VERSION }}-jira-${{ env.JIRA_CLI_VERSION }}-${{ env.CACHE_VERSION }}
          restore-keys: |
            cli-tools-${{ runner.os }}-kubectl-${{ env.KUBECTL_VERSION }}-

      - name: Install required tools
        if: steps.should_run.outputs.skip != 'true'
        run: |
          TOOL_DIR="/tmp/acm-tools"

          if [[ "${{ steps.cache-tools.outputs.cache-hit }}" == "true" ]]; then
            echo "✓ Restoring tools from cache..."
            sudo install -o root -g root -m 0755 "$TOOL_DIR/kubectl" /usr/local/bin/kubectl
            sudo install -o root -g root -m 0755 "$TOOL_DIR/oc" /usr/local/bin/oc
            sudo install -o root -g root -m 0755 "$TOOL_DIR/yq" /usr/local/bin/yq
            sudo install -o root -g root -m 0755 "$TOOL_DIR/jira" /usr/local/bin/jira
            echo "✓ All tools restored from cache in ~5 seconds"
          else
            echo "Cache miss - downloading tools..."
            mkdir -p "$TOOL_DIR"

            # Download kubectl (use pinned version)
            echo "Installing kubectl..."
            curl -L --retry 5 --retry-delay 3 --connect-timeout 30 --max-time 300 \
              -o "$TOOL_DIR/kubectl" \
              "https://dl.k8s.io/release/v${{ env.KUBECTL_VERSION }}/bin/linux/amd64/kubectl"
            chmod +x "$TOOL_DIR/kubectl"

            # Download oc (already pinned at 4.17.8)
            echo "Installing OpenShift CLI (oc)..."
            curl -L --retry 5 --retry-delay 3 --connect-timeout 30 --max-time 300 \
              -o /tmp/openshift-client-linux.tar.gz \
              "https://mirror.openshift.com/pub/openshift-v4/clients/ocp/${{ env.OC_VERSION }}/openshift-client-linux.tar.gz"
            tar -xzf /tmp/openshift-client-linux.tar.gz -C "$TOOL_DIR" oc
            chmod +x "$TOOL_DIR/oc"
            rm -f /tmp/openshift-client-linux.tar.gz

            # Download yq (use pinned version)
            echo "Installing yq..."
            curl -L --retry 3 --retry-delay 2 --fail \
              -o "$TOOL_DIR/yq" \
              "https://github.com/mikefarah/yq/releases/download/v${{ env.YQ_VERSION }}/yq_linux_amd64"
            chmod +x "$TOOL_DIR/yq"

            # Download jira-cli (use pinned version)
            echo "Installing jira-cli..."
            curl -L --retry 3 --retry-delay 2 --fail \
              -o /tmp/jira.tar.gz \
              "https://github.com/ankitpokhrel/jira-cli/releases/download/v${{ env.JIRA_CLI_VERSION }}/jira_${{ env.JIRA_CLI_VERSION }}_linux_x86_64.tar.gz"
            tar -xzf /tmp/jira.tar.gz -C /tmp
            # Find the jira binary in the extracted directory and move it to TOOL_DIR
            find /tmp/jira_* -name "jira" -type f -executable -exec mv {} "$TOOL_DIR/jira" \; -quit 2>/dev/null
            chmod +x "$TOOL_DIR/jira"
            rm -rf /tmp/jira.tar.gz /tmp/jira_*

            # Install to system
            sudo install -o root -g root -m 0755 "$TOOL_DIR/kubectl" /usr/local/bin/kubectl
            sudo install -o root -g root -m 0755 "$TOOL_DIR/oc" /usr/local/bin/oc
            sudo install -o root -g root -m 0755 "$TOOL_DIR/yq" /usr/local/bin/yq
            sudo install -o root -g root -m 0755 "$TOOL_DIR/jira" /usr/local/bin/jira
          fi

          # Skopeo: Keep apt-get install (not easily cacheable)
          echo "Installing skopeo..."
          sudo apt-get update -qq
          sudo apt-get install -y -qq skopeo

          # Verify installations
          echo "Verifying installations..."
          kubectl version --client
          oc version --client
          yq --version
          jira version
          skopeo --version

      - name: Generate GitHub App Token
        id: app-token
        if: steps.should_run.outputs.skip != 'true'
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.GH_APP_ID }}
          private-key: ${{ secrets.GH_APP_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: "acm-infra,acm-config"

      - name: Checkout repository
        if: steps.should_run.outputs.skip != 'true'
        uses: actions/checkout@v4
        with:
          token: ${{ steps.app-token.outputs.token }}
          submodules: 'recursive'

      - name: Setup scripts
        if: steps.should_run.outputs.skip != 'true'
        run: |
          echo "Using local scripts from konflux/konflux-jira-integration/scripts/"
          echo ""

          # Verify scripts exist
          if [[ ! -f "${{ github.workspace }}/konflux/konflux-jira-integration/scripts/compliance.sh" ]]; then
            echo "❌ ERROR: compliance.sh not found"
            exit 1
          fi

          if [[ ! -f "${{ github.workspace }}/konflux/konflux-jira-integration/scripts/create-compliance-jira-issues.sh" ]]; then
            echo "❌ ERROR: create-compliance-jira-issues.sh not found"
            exit 1
          fi

          echo "✓ Required scripts found"
          echo ""

          # Verify component registry configuration
          # Primary: new centralized registry from acm-config submodule
          # Fallback: old component-squad.yaml
          NEW_REGISTRY="${{ github.workspace }}/acm-config/product/component-registry.yaml"
          OLD_REGISTRY="${{ github.workspace }}/konflux/konflux-jira-integration/scripts/component-squad.yaml"

          if [[ -f "$NEW_REGISTRY" ]]; then
            echo "✓ Using new component registry: acm-config/product/component-registry.yaml"
            COMPONENT_COUNT=$(yq '.components | length' "$NEW_REGISTRY")
            echo "  Components registered: $COMPONENT_COUNT"
          elif [[ -f "$OLD_REGISTRY" ]]; then
            echo "⚠ Using legacy component-squad.yaml (new registry not found)"
            echo "  Note: Please ensure acm-config submodule is initialized"
          else
            echo "❌ ERROR: No component registry found"
            echo "  Checked: $NEW_REGISTRY"
            echo "  Checked: $OLD_REGISTRY"
            exit 1
          fi

          echo ""
          echo "✓ Configuration validated"
          echo ""
          echo "=== Scripts directory ==="
          ls -la ${{ github.workspace }}/konflux/konflux-jira-integration/scripts/
          echo ""
          echo "=== acm-config submodule status ==="
          if [[ -d "${{ github.workspace }}/acm-config" ]]; then
            ls -la ${{ github.workspace }}/acm-config/product/ || echo "  product/ directory not found"
          else
            echo "  acm-config submodule not initialized"
          fi

      - name: Validate Konflux API token
        if: steps.should_run.outputs.skip != 'true'
        env:
          KONFLUX_API_ENDPOINT: ${{ secrets.KONFLUX_API_ENDPOINT }}
          KONFLUX_API_TOKEN: ${{ secrets.KONFLUX_API_TOKEN }}
        run: |
          echo "Validating Konflux API token..."
          echo "API Endpoint: $KONFLUX_API_ENDPOINT"

          # Verify token can access the target namespace
          echo "Verifying access to crt-redhat-acm-tenant namespace..."
          if ! kubectl --server="$KONFLUX_API_ENDPOINT" \
                  --token="$KONFLUX_API_TOKEN" \
                  --insecure-skip-tls-verify \
                  get namespace crt-redhat-acm-tenant > /dev/null 2>&1; then
            echo ""
            echo "❌ Failed to access crt-redhat-acm-tenant namespace"
            echo "Possible reasons:"
            echo "  - KONFLUX_API_TOKEN has expired"
            echo "  - KONFLUX_API_TOKEN lacks access to crt-redhat-acm-tenant namespace"
            echo "  - KONFLUX_API_ENDPOINT is incorrect or unreachable"
            echo ""
            echo "Please verify and update the KONFLUX_API_TOKEN secret"
            exit 1
          fi

          echo "✓ Konflux API token is valid and has access to crt-redhat-acm-tenant namespace"

      - name: Setup Konflux cluster authentication
        if: steps.should_run.outputs.skip != 'true'
        env:
          KONFLUX_API_ENDPOINT: ${{ secrets.KONFLUX_API_ENDPOINT }}
          KONFLUX_API_TOKEN: ${{ secrets.KONFLUX_API_TOKEN }}
        run: |
          echo "Setting up Konflux cluster authentication..."

          # Configure kubectl
          kubectl config set-cluster konflux \
            --server="$KONFLUX_API_ENDPOINT" \
            --insecure-skip-tls-verify=true

          kubectl config set-credentials scanner \
            --token="$KONFLUX_API_TOKEN"

          kubectl config set-context konflux \
            --cluster=konflux \
            --user=scanner \
            --namespace=crt-redhat-acm-tenant

          kubectl config use-context konflux

          echo "✓ kubectl configured for Konflux cluster"

          # Configure oc (OpenShift CLI) to use the same context
          # oc shares the same kubeconfig with kubectl
          oc config set-cluster konflux \
            --server="$KONFLUX_API_ENDPOINT" \
            --insecure-skip-tls-verify=true

          oc config set-credentials scanner \
            --token="$KONFLUX_API_TOKEN"

          oc config set-context konflux \
            --cluster=konflux \
            --user=scanner \
            --namespace=crt-redhat-acm-tenant

          oc config use-context konflux

          echo "✓ oc configured for Konflux cluster"

          # Verify access to tenant namespace
          echo "Verifying access to crt-redhat-acm-tenant namespace..."
          if oc get namespace crt-redhat-acm-tenant > /dev/null 2>&1; then
            echo "✓ Access to crt-redhat-acm-tenant verified"
          else
            echo "WARNING: Cannot access crt-redhat-acm-tenant namespace"
          fi

          # Set current project/namespace for oc
          echo "Setting current OpenShift project..."
          if oc project crt-redhat-acm-tenant > /dev/null 2>&1; then
            echo "✓ Switched to project crt-redhat-acm-tenant"
          else
            echo "WARNING: Could not switch to project crt-redhat-acm-tenant"
          fi

      - name: Validate GitHub token
        if: steps.should_run.outputs.skip != 'true'
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
        run: |
          echo "Validating GitHub App token..."

          # Test token validity by accessing the repository
          # Note: GitHub App tokens cannot access /user endpoint, so we check repo access instead
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${{ github.repository }}")

          if [[ "$HTTP_STATUS" == "200" ]]; then
            echo "✓ GitHub App token is valid"
            echo "  Repository access verified: ${{ github.repository }}"

          elif [[ "$HTTP_STATUS" == "401" ]]; then
            echo ""
            echo "❌ GitHub App token is invalid or expired"
            echo "HTTP Status: $HTTP_STATUS (Unauthorized)"
            echo ""
            echo "Please check GitHub App configuration"
            exit 1

          elif [[ "$HTTP_STATUS" == "403" ]]; then
            echo ""
            echo "❌ GitHub App token has insufficient permissions or rate limit exceeded"
            echo "HTTP Status: $HTTP_STATUS (Forbidden)"
            echo ""
            echo "Please check:"
            echo "  - GitHub App has required permissions (contents: read)"
            echo "  - GitHub App is installed on this repository"
            echo "  - API rate limit status"
            exit 1

          elif [[ "$HTTP_STATUS" == "404" ]]; then
            echo ""
            echo "❌ Repository not found or token lacks access"
            echo "HTTP Status: $HTTP_STATUS (Not Found)"
            echo ""
            echo "Please check:"
            echo "  - GitHub App is installed on ${{ github.repository }}"
            exit 1

          else
            echo ""
            echo "❌ Unexpected response from GitHub API"
            echo "HTTP Status: $HTTP_STATUS"
            echo ""
            echo "Please verify:"
            echo "  - GitHub API is accessible"
            echo "  - GitHub App is correctly configured"
            exit 1
          fi

      - name: Setup GitHub authentication
        if: steps.should_run.outputs.skip != 'true'
        run: |
          echo "Setting up GitHub authentication..."
          mkdir -p ${{ github.workspace }}/data

          # Primary: GitHub App credentials (if available)
          # Note: We use GH_APP_* prefix instead of GITHUB_* because GitHub Actions
          #       reserves the GITHUB_* namespace and doesn't allow user secrets with that prefix.
          if [[ -n "${{ secrets.GH_APP_ID }}" && -n "${{ secrets.GH_APP_INSTALLATION_ID }}" && -n "${{ secrets.GH_APP_PRIVATE_KEY }}" ]]; then
            echo "Using GitHub App authentication"
            echo "GH_APP_ID=${{ secrets.GH_APP_ID }}" >> $GITHUB_ENV
            echo "GH_APP_INSTALLATION_ID=${{ secrets.GH_APP_INSTALLATION_ID }}" >> $GITHUB_ENV
            # Use heredoc for multiline private key
            {
              echo 'GH_APP_PRIVATE_KEY<<EOF_PRIVATE_KEY'
              echo '${{ secrets.GH_APP_PRIVATE_KEY }}'
              echo 'EOF_PRIVATE_KEY'
            } >> $GITHUB_ENV
            echo "✓ GitHub App credentials configured"
          fi

          # Use GitHub App token for all GitHub API access
          echo "GITHUB_TOKEN=${{ steps.app-token.outputs.token }}" >> $GITHUB_ENV
          echo "✓ GitHub App token configured"

          echo "✓ GitHub authentication configured"

      - name: Validate JIRA token
        if: steps.should_run.outputs.skip != 'true'
        env:
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_USER: ${{ secrets.JIRA_USER }}
        run: |
          echo "Validating JIRA connectivity..."

          # Retry logic for JIRA connectivity (max 3 attempts)
          MAX_RETRIES=3
          RETRY_DELAY=5
          ATTEMPT=1
          JIRA_VALID=false

          while [[ $ATTEMPT -le $MAX_RETRIES ]]; do
            echo "Attempting JIRA connection (attempt $ATTEMPT/$MAX_RETRIES)..."

            HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
              --connect-timeout 10 \
              --max-time 30 \
              -u "$JIRA_USER:$JIRA_API_TOKEN" \
              -H "Accept: application/json" \
              "${{ env.JIRA_SERVER }}/rest/api/2/serverInfo")

            if [[ "$HTTP_STATUS" == "200" ]]; then
              JIRA_VALID=true
              echo "✓ JIRA server is accessible and credentials are valid"
              break
            else
              if [[ "$HTTP_STATUS" == "401" ]]; then
                echo "⚠ JIRA authentication failed (HTTP 401)"
              else
                echo "⚠ Warning: JIRA server returned HTTP $HTTP_STATUS"
              fi
              if [[ $ATTEMPT -lt $MAX_RETRIES ]]; then
                echo "Retrying in ${RETRY_DELAY}s (attempt $ATTEMPT/$MAX_RETRIES)..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
              fi
            fi
            ATTEMPT=$((ATTEMPT + 1))
          done

          if [[ "$JIRA_VALID" == true ]]; then
            echo "✓ JIRA connectivity validation passed"
          else
            echo ""
            echo "⚠ Warning: Could not validate JIRA connectivity after $MAX_RETRIES attempts"
            echo "Continuing anyway - the actual JIRA operations may still work"
          fi

      - name: Setup JIRA configuration
        if: steps.should_run.outputs.skip != 'true'
        env:
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_USER: ${{ secrets.JIRA_USER }}
        run: |
          echo "Setting up JIRA CLI configuration..."

          # Create .env file for create-compliance-jira-issues.sh
          cat > ${{ github.workspace }}/.env <<EOF
          JIRA_USER=$JIRA_USER
          JIRA_API_TOKEN=$JIRA_API_TOKEN
          JIRA_AUTH_TYPE=${{ env.JIRA_AUTH_TYPE }}
          JIRA_SERVER=${{ env.JIRA_SERVER }}
          JIRA_INSTALLATION=${{ env.JIRA_INSTALLATION }}
          JIRA_PROJECT=${{ env.JIRA_PROJECT }}
          JIRA_BOARD=${{ env.JIRA_BOARD }}
          EOF

          chmod 600 ${{ github.workspace }}/.env
          echo "✓ JIRA configuration prepared"

      - name: Run compliance scan
        if: steps.should_run.outputs.skip != 'true'
        working-directory: ${{ github.workspace }}/konflux/konflux-jira-integration/scripts
        env:
          SQUAD_FILTER: ${{ github.event.inputs.squad_filter }}
        run: |
          echo "=================================================="
          echo "Running Compliance Scan for ${{ matrix.application }}"
          echo "=================================================="
          echo "Timestamp: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          echo ""

          # Build compliance command
          COMPLIANCE_CMD="./compliance.sh"

          if [[ "${{ github.event.inputs.retrigger_failed }}" == "true" ]]; then
            COMPLIANCE_CMD="$COMPLIANCE_CMD --retrigger"
            echo "Retrigger failed components: yes"
          fi

          if [[ -n "$SQUAD_FILTER" ]]; then
            COMPLIANCE_CMD="$COMPLIANCE_CMD --squad=$SQUAD_FILTER"
            echo "Squad filter: $SQUAD_FILTER"
          fi

          COMPLIANCE_CMD="$COMPLIANCE_CMD ${{ matrix.application }}"

          # Create output directories
          mkdir -p ${{ github.workspace }}/data
          mkdir -p ${{ github.workspace }}/logs

          # Enable debug output for better error tracking
          echo "=== Debug Information ==="
          echo "Current directory: $(pwd)"
          echo "Script location: $(ls -la compliance.sh)"
          echo "Environment variables:"
          echo "  GITHUB_WORKSPACE: ${{ github.workspace }}"
          echo ""

          # Export GITHUB_TOKEN for compliance.sh script
          export GITHUB_TOKEN="${{ secrets.GH_PAT }}"

          echo "Running: $COMPLIANCE_CMD"
          echo ""

          # Run with more verbose output and capture exit code
          # Use pipefail to ensure we catch failures in the pipeline
          set -o pipefail
          eval "$COMPLIANCE_CMD" 2>&1 | tee "${{ github.workspace }}/logs/${{ matrix.application }}-compliance-scan.log"
          COMPLIANCE_EXIT_CODE=$?
          set +o pipefail

          echo ""
          echo "=== Compliance Script Exit Code: $COMPLIANCE_EXIT_CODE ==="

          # The compliance.sh script creates CSV in ./data/ relative to its working directory
          # Since we're running in scripts/, the CSV is at scripts/data/
          # Move the generated CSV to the workspace data directory
          SCRIPT_CSV_FILE="./data/${{ matrix.application }}-compliance.csv"
          WORKSPACE_CSV_FILE="${{ github.workspace }}/data/${{ matrix.application }}-compliance.csv"

          echo ""
          echo "=== Files in script data directory after scan ==="
          ls -lah ./data/ || echo "Script data directory is empty or does not exist"
          echo ""

          # Move CSV file to workspace data directory if it exists
          if [[ -f "$SCRIPT_CSV_FILE" ]]; then
            echo "Moving CSV from $SCRIPT_CSV_FILE to $WORKSPACE_CSV_FILE"
            mv "$SCRIPT_CSV_FILE" "$WORKSPACE_CSV_FILE"
            echo "✓ CSV file moved successfully"
          else
            echo "❌ ERROR: Compliance CSV file not generated at: $SCRIPT_CSV_FILE"
            echo ""
            echo "=== Last 50 lines of scan log ==="
            tail -n 50 "${{ github.workspace }}/logs/${{ matrix.application }}-compliance-scan.log"
            echo ""
            echo "=== Full script data directory listing ==="
            find ./data/ -type f -ls 2>/dev/null || echo "No files found in script data directory"
            exit 1
          fi

          # Verify CSV was moved successfully
          if [[ ! -f "$WORKSPACE_CSV_FILE" ]]; then
            echo "❌ ERROR: Failed to move CSV file to workspace data directory"
            exit 1
          fi

          echo ""
          echo "✓ Compliance scan completed"
          echo "CSV file: $WORKSPACE_CSV_FILE"

          # Show summary
          TOTAL_COMPONENTS=$(tail -n +2 "$WORKSPACE_CSV_FILE" | wc -l | tr -d ' ')
          echo "Total components scanned: $TOTAL_COMPONENTS"

      - name: Create/Update JIRA issues
        if: steps.should_run.outputs.skip != 'true' && (github.event_name == 'schedule' || github.event.inputs.create_jira_issues == 'true')
        continue-on-error: true
        working-directory: ${{ github.workspace }}/konflux/konflux-jira-integration/scripts
        env:
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_USER: ${{ secrets.JIRA_USER }}
          JIRA_AUTH_TYPE: ${{ env.JIRA_AUTH_TYPE }}
          JIRA_SERVER: ${{ env.JIRA_SERVER }}
          JIRA_INSTALLATION: ${{ env.JIRA_INSTALLATION }}
          JIRA_PROJECT: ${{ env.JIRA_PROJECT }}
          JIRA_BOARD: ${{ env.JIRA_BOARD }}
        run: |
          echo "=================================================="
          echo "Creating/Updating JIRA Issues for ${{ matrix.application }}"
          echo "=================================================="
          echo ""

          CSV_FILE="${{ github.workspace }}/data/${{ matrix.application }}-compliance.csv"
          JSON_OUTPUT="${{ github.workspace }}/logs/${{ matrix.application }}-jira-issues.json"

          # Build JIRA command
          JIRA_CMD="./create-compliance-jira-issues.sh"

          if [[ "${{ env.SKIP_DUPLICATES }}" == "true" ]]; then
            JIRA_CMD="$JIRA_CMD --skip-duplicates"
          fi

          if [[ "${{ env.AUTO_CLOSE }}" == "true" ]]; then
            JIRA_CMD="$JIRA_CMD --auto-close"
          fi

          if [[ -n "${{ env.JIRA_PRIORITY }}" ]]; then
            JIRA_CMD="$JIRA_CMD --priority ${{ env.JIRA_PRIORITY }}"
          fi

          if [[ -n "${{ env.JIRA_LABELS }}" ]]; then
            JIRA_CMD="$JIRA_CMD --labels ${{ env.JIRA_LABELS }}"
          fi

          JIRA_CMD="$JIRA_CMD --output-json $JSON_OUTPUT"
          JIRA_CMD="$JIRA_CMD --continue-on-error"
          JIRA_CMD="$JIRA_CMD $CSV_FILE"

          echo "Running: $JIRA_CMD"

          # Use pipefail to ensure we catch failures in the pipeline
          set -o pipefail
          eval "$JIRA_CMD" 2>&1 | tee "${{ github.workspace }}/logs/${{ matrix.application }}-jira-creation.log"
          JIRA_EXIT_CODE=$?
          set +o pipefail

          echo ""

          if [[ $JIRA_EXIT_CODE -eq 0 ]]; then
            echo "✓ JIRA issue creation/update completed successfully"

            if [[ -f "$JSON_OUTPUT" ]]; then
              echo "JSON output: $JSON_OUTPUT"
            fi
          else
            echo "⚠ JIRA issue creation/update completed with some errors (exit code: $JIRA_EXIT_CODE)"
            echo "Please check the log file for details: logs/${{ matrix.application }}-jira-creation.log"
            echo "Note: Workflow will continue despite errors"
          fi

      - name: Upload scan results
        if: always() && steps.should_run.outputs.skip != 'true' && env.ACT != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: compliance-results-${{ matrix.application }}
          path: |
            ${{ github.workspace }}/data/${{ matrix.application }}-compliance.csv
            ${{ github.workspace }}/logs/${{ matrix.application }}-*.log
            ${{ github.workspace }}/logs/${{ matrix.application }}-*.json
          retention-days: 30

      - name: Log completion
        if: steps.should_run.outputs.skip != 'true'
        run: |
          # Console output only - no GITHUB_STEP_SUMMARY (aggregated summary will be generated later)
          echo "=================================================="
          echo "Compliance Scan Completed Successfully"
          echo "=================================================="
          echo "Application: ${{ matrix.application }}"
          echo "Timestamp: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          echo ""
          echo "Output files:"
          echo "  - CSV: data/${{ matrix.application }}-compliance.csv"
          echo "  - Scan Log: logs/${{ matrix.application }}-compliance-scan.log"
          echo "  - JIRA Log: logs/${{ matrix.application }}-jira-creation.log"
          echo "  - JSON: logs/${{ matrix.application }}-jira-issues.json"
          echo ""

  aggregate-summary:
    name: Aggregate Summary Report
    runs-on: ubuntu-latest
    needs: compliance-scan
    if: always()
    timeout-minutes: 10

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: compliance-results-*
          path: artifacts/
          merge-multiple: false
        continue-on-error: true

      - name: Generate aggregate summary
        run: |
          echo "=========================================="
          echo "Generating Aggregate Compliance Summary"
          echo "=========================================="
          echo ""

          # Expected applications list
          EXPECTED_APPS="acm-211 acm-212 acm-213 acm-214 acm-215 acm-216 mce-26 mce-27 mce-28 mce-29 mce-210 mce-211"

          # Initialize counters
          TOTAL_COMPONENTS=0
          TOTAL_ISSUES=0
          TOTAL_FAILED_PUSH=0
          TOTAL_NOT_COMPLIANT=0
          TOTAL_HERMETIC_DISABLED=0
          TOTAL_MULTIARCH_DISABLED=0
          TOTAL_PROMOTION_FAILED=0

          JIRA_CREATED=0
          JIRA_UPDATED=0
          JIRA_CLOSED=0

          APPS_PROCESSED=0
          APPS_WITH_ISSUES=0

          # Temporary files for aggregation
          mkdir -p /tmp/aggregate
          > /tmp/aggregate/app_stats.txt
          > /tmp/aggregate/push_failures.txt
          > /tmp/aggregate/ec_failures.txt
          > /tmp/aggregate/hermetic_failures.txt
          > /tmp/aggregate/multiarch_failures.txt
          > /tmp/aggregate/promotion_failures.txt
          > /tmp/aggregate/jira_issues.txt

          # Find all CSV files
          CSV_FILES=$(find artifacts/ -name "*-compliance.csv" -type f 2>/dev/null | sort) || true

          if [[ -z "$CSV_FILES" ]]; then
            echo "## :warning: Aggregate Compliance Summary" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "No compliance scan results available." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "This may occur if:" >> $GITHUB_STEP_SUMMARY
            echo "- All matrix jobs were skipped due to application filter" >> $GITHUB_STEP_SUMMARY
            echo "- All matrix jobs failed before producing output" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          echo "Found CSV files:"
          echo "$CSV_FILES"
          echo ""

          # Process each CSV file
          for csv_file in $CSV_FILES; do
            app_name=$(basename "$csv_file" | sed 's/-compliance\.csv$//')
            artifact_dir=$(dirname "$(dirname "$csv_file")")

            echo "Processing: $app_name"

            # Count components (excluding header)
            component_count=$(tail -n +2 "$csv_file" | wc -l | tr -d ' ')

            # Count by status - ensure numeric values
            failed_push=$(tail -n +2 "$csv_file" | awk -F',' '{print $8}' | grep -c "Failed" 2>/dev/null || true)
            failed_push=$(echo "$failed_push" | tr -d '[:space:]')
            [[ -z "$failed_push" || ! "$failed_push" =~ ^[0-9]+$ ]] && failed_push=0

            not_compliant=$(tail -n +2 "$csv_file" | awk -F',' '{print $6}' | grep -c "Not Compliant" 2>/dev/null || true)
            not_compliant=$(echo "$not_compliant" | tr -d '[:space:]')
            [[ -z "$not_compliant" || ! "$not_compliant" =~ ^[0-9]+$ ]] && not_compliant=0

            hermetic_disabled=$(tail -n +2 "$csv_file" | awk -F',' '{print $5}' | grep -c "Not Enabled" 2>/dev/null || true)
            hermetic_disabled=$(echo "$hermetic_disabled" | tr -d '[:space:]')
            [[ -z "$hermetic_disabled" || ! "$hermetic_disabled" =~ ^[0-9]+$ ]] && hermetic_disabled=0

            multiarch_disabled=$(tail -n +2 "$csv_file" | awk -F',' '{print $7}' | grep -c "Not Enabled" 2>/dev/null || true)
            multiarch_disabled=$(echo "$multiarch_disabled" | tr -d '[:space:]')
            [[ -z "$multiarch_disabled" || ! "$multiarch_disabled" =~ ^[0-9]+$ ]] && multiarch_disabled=0

            promotion_failed=$(tail -n +2 "$csv_file" | awk -F',' '{print $4}' | grep -cE "(Failed|IMAGE_PULL_FAILURE|INSPECTION_FAILURE|DIGEST_FAILURE)" 2>/dev/null || true)
            promotion_failed=$(echo "$promotion_failed" | tr -d '[:space:]')
            [[ -z "$promotion_failed" || ! "$promotion_failed" =~ ^[0-9]+$ ]] && promotion_failed=0

            # Calculate issues for this app
            app_issues=$((failed_push + not_compliant + hermetic_disabled + multiarch_disabled + promotion_failed))
            app_compliant=$((component_count - app_issues))

            # Store per-app stats
            echo "$app_name,$component_count,$app_compliant,$failed_push,$not_compliant,$hermetic_disabled,$multiarch_disabled,$promotion_failed" >> /tmp/aggregate/app_stats.txt

            # Accumulate totals
            TOTAL_COMPONENTS=$((TOTAL_COMPONENTS + component_count))
            TOTAL_FAILED_PUSH=$((TOTAL_FAILED_PUSH + failed_push))
            TOTAL_NOT_COMPLIANT=$((TOTAL_NOT_COMPLIANT + not_compliant))
            TOTAL_HERMETIC_DISABLED=$((TOTAL_HERMETIC_DISABLED + hermetic_disabled))
            TOTAL_MULTIARCH_DISABLED=$((TOTAL_MULTIARCH_DISABLED + multiarch_disabled))
            TOTAL_PROMOTION_FAILED=$((TOTAL_PROMOTION_FAILED + promotion_failed))

            APPS_PROCESSED=$((APPS_PROCESSED + 1))
            if [[ $app_issues -gt 0 ]]; then
              APPS_WITH_ISSUES=$((APPS_WITH_ISSUES + 1))
            fi

            # Collect failed components details
            tail -n +2 "$csv_file" | while IFS=',' read -r component scan_time promoted_time promotion_status hermetic_status ec_status multiarch_status push_status push_url ec_url; do
              if [[ "$push_status" == "Failed" ]]; then
                echo "$app_name|$component|$push_url" >> /tmp/aggregate/push_failures.txt
              fi
              if [[ "$ec_status" == "Not Compliant" ]]; then
                echo "$app_name|$component|$ec_url" >> /tmp/aggregate/ec_failures.txt
              fi
              if [[ "$hermetic_status" == "Not Enabled" ]]; then
                echo "$app_name|$component" >> /tmp/aggregate/hermetic_failures.txt
              fi
              if [[ "$multiarch_status" == "Not Enabled" ]]; then
                echo "$app_name|$component" >> /tmp/aggregate/multiarch_failures.txt
              fi
              if [[ "$promotion_status" =~ (Failed|IMAGE_PULL_FAILURE|INSPECTION_FAILURE|DIGEST_FAILURE) ]]; then
                echo "$app_name|$component|$promotion_status" >> /tmp/aggregate/promotion_failures.txt
              fi
            done

            # Process JIRA logs
            jira_log="$artifact_dir/logs/${app_name}-jira-creation.log"
            if [[ -f "$jira_log" ]]; then
              # Strip ANSI color codes and extract counts from lines like "Issues created: 3"
              # The log format is: [0;32mIssues created:[0m 3
              created=$(sed 's/\x1b\[[0-9;]*m//g' "$jira_log" 2>/dev/null | grep "Issues created:" | sed 's/.*Issues created:[[:space:]]*//' | tr -d '[:space:]' | tail -1)
              updated=$(sed 's/\x1b\[[0-9;]*m//g' "$jira_log" 2>/dev/null | grep "Issues updated:" | sed 's/.*Issues updated:[[:space:]]*//' | tr -d '[:space:]' | tail -1)
              closed=$(sed 's/\x1b\[[0-9;]*m//g' "$jira_log" 2>/dev/null | grep "Issues closed:" | sed 's/.*Issues closed:[[:space:]]*//' | tr -d '[:space:]' | tail -1)

              # Ensure numeric values (default to 0 if empty or non-numeric)
              [[ ! "$created" =~ ^[0-9]+$ ]] && created=0
              [[ ! "$updated" =~ ^[0-9]+$ ]] && updated=0
              [[ ! "$closed" =~ ^[0-9]+$ ]] && closed=0

              JIRA_CREATED=$((JIRA_CREATED + created))
              JIRA_UPDATED=$((JIRA_UPDATED + updated))
              JIRA_CLOSED=$((JIRA_CLOSED + closed))

              # Extract JIRA issue keys from URLs like https://issues.redhat.com/browse/ACM-27481
              # The log contains lines like: • component: https://issues.redhat.com/browse/ACM-27481
              grep -oE 'ACM-[0-9]+' "$jira_log" 2>/dev/null | sort -u >> /tmp/aggregate/jira_issues.txt || true
            fi
          done

          # Calculate totals
          TOTAL_ISSUES=$((TOTAL_FAILED_PUSH + TOTAL_NOT_COMPLIANT + TOTAL_HERMETIC_DISABLED + TOTAL_MULTIARCH_DISABLED + TOTAL_PROMOTION_FAILED))
          TOTAL_COMPLIANT=$((TOTAL_COMPONENTS - TOTAL_ISSUES))

          # Identify skipped applications
          SKIPPED_APPS=""
          for expected in $EXPECTED_APPS; do
            if ! grep -q "^$expected," /tmp/aggregate/app_stats.txt 2>/dev/null; then
              SKIPPED_APPS="$SKIPPED_APPS $expected"
            fi
          done

          # Generate Summary
          echo "# :clipboard: Aggregate Compliance Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
          echo "**Applications Processed:** $APPS_PROCESSED" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Determine overall status
          if [[ $TOTAL_ISSUES -eq 0 ]]; then
            echo "## :white_check_mark: All Components Compliant" >> $GITHUB_STEP_SUMMARY
          else
            echo "## :warning: Compliance Issues Detected" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          # Global Overview
          echo "### :bar_chart: Global Overview" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Total Components | $TOTAL_COMPONENTS |" >> $GITHUB_STEP_SUMMARY
          echo "| Fully Compliant | $TOTAL_COMPLIANT |" >> $GITHUB_STEP_SUMMARY
          echo "| With Issues | $TOTAL_ISSUES |" >> $GITHUB_STEP_SUMMARY
          echo "| Applications with Issues | $APPS_WITH_ISSUES / $APPS_PROCESSED |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Per-Application Overview
          echo "### :package: Per-Application Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Application | Total | Compliant | Push Fail | EC Fail | Hermetic | Multiarch | Promotion |" >> $GITHUB_STEP_SUMMARY
          echo "|-------------|-------|-----------|-----------|---------|----------|-----------|-----------|" >> $GITHUB_STEP_SUMMARY

          while IFS=',' read -r app total compliant push ec hermetic multi promo; do
            if [[ $((push + ec + hermetic + multi + promo)) -eq 0 ]]; then
              status_icon=":white_check_mark:"
            else
              status_icon=":x:"
            fi
            echo "| $status_icon \`$app\` | $total | $compliant | $push | $ec | $hermetic | $multi | $promo |" >> $GITHUB_STEP_SUMMARY
          done < /tmp/aggregate/app_stats.txt

          echo "| **TOTAL** | **$TOTAL_COMPONENTS** | **$TOTAL_COMPLIANT** | **$TOTAL_FAILED_PUSH** | **$TOTAL_NOT_COMPLIANT** | **$TOTAL_HERMETIC_DISABLED** | **$TOTAL_MULTIARCH_DISABLED** | **$TOTAL_PROMOTION_FAILED** |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Skipped Applications
          if [[ -n "$SKIPPED_APPS" ]]; then
            echo "### :fast_forward: Skipped Applications" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The following applications were skipped or failed to produce artifacts:" >> $GITHUB_STEP_SUMMARY
            for app in $SKIPPED_APPS; do
              echo "- \`$app\`" >> $GITHUB_STEP_SUMMARY
            done
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # JIRA Statistics
          echo "### :ticket: JIRA Integration Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Action | Count |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Issues Created | $JIRA_CREATED |" >> $GITHUB_STEP_SUMMARY
          echo "| Issues Updated | $JIRA_UPDATED |" >> $GITHUB_STEP_SUMMARY
          echo "| Issues Auto-Closed | $JIRA_CLOSED |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # JIRA Issue Links
          jira_count=$(sort -u /tmp/aggregate/jira_issues.txt 2>/dev/null | wc -l | tr -d ' ')
          jira_count=${jira_count:-0}
          if [[ $jira_count -gt 0 ]]; then
            echo "<details>" >> $GITHUB_STEP_SUMMARY
            echo "<summary>JIRA Issues ($jira_count unique)</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            sort -u /tmp/aggregate/jira_issues.txt | while read -r issue_key; do
              if [[ -n "$issue_key" ]]; then
                echo "- [$issue_key](https://issues.redhat.com/browse/$issue_key)" >> $GITHUB_STEP_SUMMARY
              fi
            done
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Failure Details by Type
          echo "### :mag: Failure Details by Type" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Push Failures
          if [[ $TOTAL_FAILED_PUSH -gt 0 ]]; then
            echo "<details>" >> $GITHUB_STEP_SUMMARY
            echo "<summary>:x: Push Pipeline Failures ($TOTAL_FAILED_PUSH)</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Application | Component | Link |" >> $GITHUB_STEP_SUMMARY
            echo "|-------------|-----------|------|" >> $GITHUB_STEP_SUMMARY
            sort /tmp/aggregate/push_failures.txt 2>/dev/null | while IFS='|' read -r app comp url; do
              if [[ -n "$url" && "$url" != "null" ]]; then
                echo "| \`$app\` | \`$comp\` | [View]($url) |" >> $GITHUB_STEP_SUMMARY
              else
                echo "| \`$app\` | \`$comp\` | - |" >> $GITHUB_STEP_SUMMARY
              fi
            done
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # EC Failures
          if [[ $TOTAL_NOT_COMPLIANT -gt 0 ]]; then
            echo "<details>" >> $GITHUB_STEP_SUMMARY
            echo "<summary>:x: Enterprise Contract Failures ($TOTAL_NOT_COMPLIANT)</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Application | Component | Link |" >> $GITHUB_STEP_SUMMARY
            echo "|-------------|-----------|------|" >> $GITHUB_STEP_SUMMARY
            sort /tmp/aggregate/ec_failures.txt 2>/dev/null | while IFS='|' read -r app comp url; do
              if [[ -n "$url" && "$url" != "null" ]]; then
                echo "| \`$app\` | \`$comp\` | [View]($url) |" >> $GITHUB_STEP_SUMMARY
              else
                echo "| \`$app\` | \`$comp\` | - |" >> $GITHUB_STEP_SUMMARY
              fi
            done
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Hermetic Failures
          if [[ $TOTAL_HERMETIC_DISABLED -gt 0 ]]; then
            echo "<details>" >> $GITHUB_STEP_SUMMARY
            echo "<summary>:x: Hermetic Builds Disabled ($TOTAL_HERMETIC_DISABLED)</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            sort /tmp/aggregate/hermetic_failures.txt 2>/dev/null | while IFS='|' read -r app comp; do
              echo "- \`$app\`: \`$comp\`" >> $GITHUB_STEP_SUMMARY
            done
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Multiarch Failures
          if [[ $TOTAL_MULTIARCH_DISABLED -gt 0 ]]; then
            echo "<details>" >> $GITHUB_STEP_SUMMARY
            echo "<summary>:x: Multiarch Support Disabled ($TOTAL_MULTIARCH_DISABLED)</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            sort /tmp/aggregate/multiarch_failures.txt 2>/dev/null | while IFS='|' read -r app comp; do
              echo "- \`$app\`: \`$comp\`" >> $GITHUB_STEP_SUMMARY
            done
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          # Promotion Failures
          if [[ $TOTAL_PROMOTION_FAILED -gt 0 ]]; then
            echo "<details>" >> $GITHUB_STEP_SUMMARY
            echo "<summary>:x: Image Promotion Failures ($TOTAL_PROMOTION_FAILED)</summary>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Application | Component | Status |" >> $GITHUB_STEP_SUMMARY
            echo "|-------------|-----------|--------|" >> $GITHUB_STEP_SUMMARY
            sort /tmp/aggregate/promotion_failures.txt 2>/dev/null | while IFS='|' read -r app comp status; do
              echo "| \`$app\` | \`$comp\` | $status |" >> $GITHUB_STEP_SUMMARY
            done
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "</details>" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi

          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "_Report generated by aggregate-summary job_" >> $GITHUB_STEP_SUMMARY

          # Console output
          echo ""
          echo "=========================================="
          echo "Aggregate Summary Generated Successfully"
          echo "=========================================="
          echo "Total Components: $TOTAL_COMPONENTS"
          echo "Compliant: $TOTAL_COMPLIANT"
          echo "With Issues: $TOTAL_ISSUES"
          echo "JIRA Created: $JIRA_CREATED"
          echo "JIRA Updated: $JIRA_UPDATED"
          echo "JIRA Closed: $JIRA_CLOSED"
